### テストの粒度
* Unit test/component test: 最も細かい粒度のテスト。個々の関数やメソッドは、さまざまな入力に対して期待される出力を返すかどうか(正しく動作するか)を確認する。
* Integration test:複数のユニットが組み合わさったときに正しく動作するかを確認する、例えば、データベースとのやり取りや外部APIとの連携をテストする。
  --- Regression test: バグやエラーが特定された後にプログラムが修正され、その後きちんと修正されたことを確認するためのデバッグ及びトラブルシューティングプロセスの一部。
                            同じミスを回避するために使用される。
  --- Smoke test/Build verification test: ソフトウェアやシステムの基本的な機能が正常に動作するかを簡易的に確認する。
                                               unit testの前に開発プロセスの初期段階や、新しいビルドがリリースされた際に実施され、迅速な重大なバグの発見や手戻り回避につながる。
* System test: アプリケーション全体が要件を満たしているかを総合的に確認する。ユーザの観点から機能をテストする。
* User acceptance Test: 最終的なユーザやクライアントがアプリケーションを受け入れるためのテスト。ビジネス要件が満たされているかを確認する。
* ※ 基本的にはユニットテストをしっかりと行い、必要に応じて統合テストやシステムテストを行うことでバランスの取れたテスト戦略を構築することが可能。

### テストケースの設計
# 正常系テスト: 正常な入力に対して期待される出力を確認する。基本的なテストであり、必ず行うべき。
# 異常系テスト: 異常な入力（無効なデータやエッジケース）に対して、アプリケーションが適切にエラーハンドリングを行うかを確認。
# 境界値テスト: rangeの境界に近い値（例えば、リストの最初や最後の要素、最大値や最小値など）をテストする。これにより、オフバイワンエラー（1つずれたエラー）を検出しやすくなる。
# ※ 過剰なテストは避け、重要な機能や頻繁に更新変更される部分を優先して作成する。コードカバレッジは70-80%を目指すことが一般的ではあるが、高いカバレッジが高い品質を示すとは限らない。
#    テストケースもメンテナンスが必要なため、テストケースは明確にしておくべき。

### テストケースの種類
# White Box test: 
# 対象ソフトウェアの仕組みに関する知識に基づいて作成されるため、高いカバレッジを得ることが可能。コードによってテスト御ケースが偏る可能性が低くなる
# イメージは、関数をつくりながら、その関数がどんな結果をもたらすかのテストコードを書いてチェックしながら目的の関数が出来上がるまでバグやエラーハンドリングを追加する等修正し続ける、そんな感じ
# なお、修正する箇所はなるべく少ない方が良いので、複数のエラーの原因を作っている箇所を特定し問題を集約して最適解を修正として盛り込むのがベスト！
# Black Box test:
# 対象ソフトウェアの内部的な仕組みを知らずに行うため、元開発者の予期しない状況をカバーすることが可能。
# コードが何をすべきかの仕様に基づいてコードが記述される前にユニットテストが作成された場合、要は時間軸的な観点から、ブラックボックステストだといえる。
# えーと？これ可能なの？要件定義書がしっかりしていれば可能なのか？
